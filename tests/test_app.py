import pathlib
from unittest import mock

import pytest
from barrier.configure import RequiredEnvironmentError
from flask import url_for


def test_client_secrets_json_missing():
    """Should fail to import/run service without a client-secrets.json generated by ``barrier-config``."""
    assert not pathlib.Path(
        "client-secrets.json"
    ).exists(), "Move or delete client-secrets.json before running the test suite."

    with pytest.raises(RequiredEnvironmentError, match="client-secrets.json"):
        from barrier import app  # noqa: F401


def test_secret_key_missing():
    """Should fail to import/run service without a secret key to sign/verify requests via HMAC."""
    with mock.patch("flask_oidc.OpenIDConnect"):
        with pytest.raises(RequiredEnvironmentError, match="BARRIER_SECRET_KEY"):
            from barrier import app  # noqa: F401


def test_root_route_without_session(client):
    """Should induce redirect to index.html."""
    from barrier.app import oidc

    response = client.get("/")
    assert response.status_code == 302
    assert response.location.startswith(oidc.client_secrets["auth_uri"])


def test_login_route_without_session(client):
    """Should induce redirect to login page."""
    from barrier.app import oidc

    response = client.get(url_for(".login"))
    assert response.location.startswith(oidc.client_secrets["auth_uri"])


def test_logout_route_without_session(client):
    """Should induce redirect to login page."""
    from barrier.app import oidc

    response = client.get(url_for(".logout"))
    assert response.location.startswith(oidc.client_secrets["auth_uri"])


def test_resource_proxy_route_without_session(client):
    """Should induce redirect to login page."""
    from barrier.app import oidc

    response = client.get("/test-resource.html")
    assert response.location.startswith(oidc.client_secrets["auth_uri"])


def test_root_route_with_session(client):
    """Should induce redirect to default resource."""
    from barrier.app import app, root

    root.settings["allow_all_traffic"] = True

    response = client.get(url_for(".root"))
    assert response.status_code == 302
    assert response.location.endswith(app.config["DEFAULT_RESOURCE"]), response.location


def test_login_route_with_session(client):
    """Should induce redirect to default resource."""
    from barrier.app import app, login

    login.settings["allow_all_traffic"] = True

    response = client.get(url_for(".login"))
    assert response.location.endswith(app.config["DEFAULT_RESOURCE"]), response.location


@mock.patch("barrier.app.oidc", mock.MagicMock())
@mock.patch("barrier.app.OAuth2Credentials.from_json")
def test_logout_route_with_session(patched_oauth2_credentials, client):
    """Should redirect user to OpenIDConnect logout endpoint with session id hint as a query parameter."""
    from barrier.app import logout

    # Bypass login check
    logout.settings["allow_all_traffic"] = True

    # Mock the credentials issuer to be expected as the domain to be redirected to
    ISSUER_URI = "https://issuer-uri"
    patched_oauth2_credentials().id_token = {"iss": ISSUER_URI}

    # Mock JSON Web Token ID to be expected in redirect URI's query parameter
    ID_TOKEN = "0123456789"
    patched_oauth2_credentials().token_response = {"id_token": ID_TOKEN}

    response = client.get(url_for(".logout"))
    assert response.status_code == 302
    assert response.location.startswith(ISSUER_URI)
    assert response.location.endswith(ID_TOKEN)


@mock.patch("barrier.app.oidc")
@mock.patch("barrier.app.OAuth2Credentials.from_json", mock.MagicMock())
def test_logout_with_bad_state(patched_open_id_connect, client):
    """Should redirect in hairpin maneuver to obtain session information through auth service callback."""
    from barrier.app import logout

    # Bypass login check
    logout.settings["allow_all_traffic"] = True

    # Mock missing user details in local cache
    patched_open_id_connect.user_getfield.side_effect = [KeyError]
    # Fake a 200 OK for simplicity
    patched_open_id_connect.redirect_to_auth_server.return_value = "Mock OK"

    client.get(url_for(".logout"))

    # Make sure we will be redirected in hairpin maneuver back to logout from the auth service.
    patched_open_id_connect.redirect_to_auth_server.assert_called_once_with(url_for(".logout"))


def test_resource_proxy_route_with_session_and_no_file(client):
    """Should fail to find missing file for authenticated user."""
    from barrier.app import resource_proxy

    resource_proxy.settings["allow_all_traffic"] = True

    response = client.get("/test-resource.html")
    assert response.status_code == 404


def test_resource_proxy_route_with_session_and_existing_file(client, tmp_path):
    """Should proxy resource for authenticated user."""
    from barrier.app import app, resource_proxy

    resource_name = "test-resource.html"
    (tmp_path / resource_name).write_text("Test")
    app.config["RESOURCE_ROOT"] = str(tmp_path)
    resource_proxy.settings["allow_all_traffic"] = True

    response = client.get(f"/{resource_name}")
    assert response.status_code == 200, app.config["RESOURCE_ROOT"]
